<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Super Mario Jumper</title>

<style>
    body {
        margin: 0;
        overflow: hidden;
        background: #87CEEB;
        touch-action: none;
        -webkit-user-select: none;
        user-select: none;
    }
    canvas {
        display: block;
    }
</style>
</head>

<body>
<canvas id="gameCanvas"></canvas>

<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");

let gameRunning = true;
let lives = 5;
let score = 0;
let invincible = 0;
let enemies = [];
let groundY = 0;
let mario = {};
let lastSpawn = 0;
let spawnInterval = 2.5;
let startTime = 0;

let audioCtx = null;
let audioUnlocked = false;

/* ---------------- AUDIO (iOS FIX) ---------------- */
function unlockAudio() {
    if (!audioCtx) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    }
    if (audioCtx.state === "suspended") {
        audioCtx.resume();
    }
    audioUnlocked = true;
}

function playSound(freq, duration) {
    if (!audioUnlocked) return;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.frequency.value = freq;
    osc.type = "square";
    gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(
        0.01,
        audioCtx.currentTime + duration / 1000
    );
    osc.start();
    osc.stop(audioCtx.currentTime + duration / 1000);
}

/* ---------------- SETUP ---------------- */
function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    groundY = canvas.height * 0.85;

    mario = {
        x: Math.min(200, canvas.width * 0.18),
        y: groundY - 60,
        w: 45,
        h: 60,
        vy: 0,
        onGround: true
    };
}

function init() {
    resizeCanvas();
    enemies = [];
    lives = 5;
    score = 0;
    invincible = 0;
    startTime = performance.now() / 1000;
    lastSpawn = startTime;
    gameRunning = true;
    requestAnimationFrame(loop);
}

function reset() {
    init();
}

/* ---------------- GAME LOGIC ---------------- */
function spawnEnemy() {
    const types = [
        { w: 40, h: 45, speed: 5 },
        { w: 38, h: 42, speed: 4 }
    ];
    const t = types[Math.floor(Math.random() * types.length)];
    enemies.push({
        ...t,
        x: canvas.width + 50,
        y: groundY - t.h
    });
}

function update() {
    const now = performance.now() / 1000;

    if (gameRunning) {
        if (now - lastSpawn > spawnInterval) {
            spawnEnemy();
            lastSpawn = now;
        }

        mario.vy += 0.8;
        mario.y += mario.vy;

        if (mario.y >= groundY - mario.h) {
            mario.y = groundY - mario.h;
            mario.vy = 0;
            mario.onGround = true;
        }

        for (let i = enemies.length - 1; i >= 0; i--) {
            const e = enemies[i];
            e.x -= e.speed;

            if (e.x < -e.w) enemies.splice(i, 1);

            const hit =
                mario.x < e.x + e.w &&
                mario.x + mario.w > e.x &&
                mario.y < e.y + e.h &&
                mario.y + mario.h > e.y;

            if (hit && invincible <= 0) {
                lives--;
                invincible = 90;
                playSound(196, 200);
                if (lives <= 0) gameRunning = false;
            }
        }

        invincible--;
    }
}

/* ---------------- DRAW ---------------- */
function drawMario() {
    ctx.fillStyle = "red";
    ctx.fillRect(mario.x, mario.y, mario.w, mario.h);
}

function drawEnemy(e) {
    ctx.fillStyle = "brown";
    ctx.fillRect(e.x, e.y, e.w, e.h);
}

function drawUI() {
    ctx.fillStyle = "white";
    ctx.font = "24px Arial Black";
    ctx.fillText(`Lives: ${lives}`, 20, 40);
    ctx.fillText(`Score: ${score}`, canvas.width / 2 - 50, 40);
}

function drawGameOver() {
    ctx.fillStyle = "rgba(0,0,0,0.8)";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = "white";
    ctx.font = "48px Arial Black";
    ctx.textAlign = "center";
    ctx.fillText("GAME OVER", canvas.width / 2, canvas.height / 2);
    ctx.font = "24px Arial";
    ctx.fillText("Tap to Restart", canvas.width / 2, canvas.height / 2 + 50);
}

/* ---------------- LOOP ---------------- */
function loop() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    update();

    enemies.forEach(drawEnemy);
    drawMario();
    drawUI();

    if (!gameRunning) drawGameOver();

    requestAnimationFrame(loop);
}

/* ---------------- TOUCH CONTROLS (iPhone FIX) ---------------- */
function handleTap() {
    unlockAudio();

    if (!gameRunning) {
        reset();
        return;
    }

    if (mario.onGround) {
        mario.vy = -17;
        mario.onGround = false;
        playSound(523, 120);
    }
}

canvas.addEventListener("touchstart", (e) => {
    e.preventDefault();
    handleTap();
}, { passive: false });

canvas.addEventListener("mousedown", handleTap);

/* ---------------- START ---------------- */
window.addEventListener("resize", resizeCanvas);
init();
</script>
</body>
</html>
